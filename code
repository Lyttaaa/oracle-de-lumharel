import os
import sys
import asyncio
from datetime import datetime, timedelta

import discord
from discord.ext import commands, tasks
from discord.errors import Forbidden
from pymongo import MongoClient

from aiohttp import web            # NEW
from discord import app_commands   # NEW

# ======================
#   ENV & INTENTS
# ======================
TOKEN = os.getenv("DISCORD_TOKEN")
MONGO_URI = os.getenv("MONGO_URI")
GUILD_ID_STR = os.getenv("GUILD_ID", "").strip()
GUILD_ID = int(GUILD_ID_STR) if GUILD_ID_STR.isdigit() else 0  # 0 = pas de filtre

if not TOKEN:
    print("‚ùå DISCORD_TOKEN manquant en variable d'environnement.")
    sys.exit(1)
if not MONGO_URI:
    print("‚ùå MONGO_URI manquant en variable d'environnement.")
    sys.exit(1)

intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.reactions = True
intents.message_content = True
intents.messages = True

bot = commands.Bot(command_prefix="!", intents=intents)

# ======================
#   MONGO
# ======================
try:
    mongo = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
    mongo.admin.command("ping")
    print("üü¢ MongoDB OK")
except Exception as e:
    print("üî¥ MongoDB KO:", e)
    sys.exit(1)

db = mongo.lumharel_bot
utilisateurs = db.utilisateurs
liens = db.liens_twitch_discord  # NEW
# indexes utiles (cr√©√©s √† chaud; si d√©j√† faits, Mongo ignore)
try:
    liens.create_index([("_id", 1)], unique=True)
    liens.create_index([("discord_id", 1)], unique=False)
except Exception as e:
    print("‚ÑπÔ∏è Index liens_twitch_discord:", e)

# ======================
#   PARAM√àTRES AUTELS
# ======================
# D√©finir 1 message Discord par divinit√© (m√™me message pour pri√®res & offrandes)
DEITES = {
    "Orrak": {
        "message_id": 1353249202523865153,
        "priere_emoji": "üåø",
        "role": "B√©ni¬∑e par la Terre",
        "offrandes": ["üçÉ", "üå∞", "üçÑ", "üçÇ"],
    },
    "Vaek": {
        "message_id": 1353255384948801637,
        "priere_emoji": "üî•",
        "role": "Marqu√©¬∑e par la Flamme",
        "offrandes": ["üß®", "üî®", "üîß", "üß±"],
    },
    "Nhyara": {
        "message_id": 1353255533544734751,
        "priere_emoji": "üå™Ô∏è",
        "role": "Guid√©¬∑e par les Vents",
        "offrandes": ["üí®", "üéê", "üå¨Ô∏è", "üí´"],
    },
    "Zeroth": {
        "message_id": 1353255680462819450,
        "priere_emoji": "üåë",
        "role": "Voil√©¬∑e par les Ombres",
        "offrandes": ["‚ö∞Ô∏è", "üï∏Ô∏è", "üñ§", "üóùÔ∏è"],
    },
    "A√´ldis": {
        "message_id": 1353257057679052910,
        "priere_emoji": "‚ùÑÔ∏è",
        "role": "Port√©¬∑e par le Silence",
        "offrandes": ["‚òÉÔ∏è", "üßä", "üåô", "‚òÅÔ∏è"],
    },
}

LUMES_PAR_OFFRANDE = 5
DUREE_BENEDICTION_H = 24  # pour le nettoyage du r√¥le, c√¥t√© base

# ======================
#   HELPERS
# ======================
def today_str() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d")

async def send_temp(channel: discord.abc.Messageable | None, content: str, seconds: int = 10):
    if not channel:
        return
    try:
        m = await channel.send(content)
        await asyncio.sleep(seconds)
        try:
            await m.delete()
        except:
            pass
    except:
        pass

def find_deity_by_message(message_id: int):
    for name, conf in DEITES.items():
        if conf["message_id"] == message_id:
            return name, conf
    return None, None

# ======================
#   SLASH COMMANDS: link/unlink Twitch
# ======================
@bot.tree.command(name="ping", description="Test")
async def ping_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("pong", ephemeral=True)
@bot.tree.command(name="linktwitch", description="Lier ton pseudo Twitch √† ton Discord")
@app_commands.describe(pseudo="Ton pseudo Twitch (exact)")
async def linktwitch(interaction: discord.Interaction, pseudo: str):
    """Associe twitch_login_lower -> discord_id (ephemeral feedback)."""
    twitch_login = (pseudo or "").strip().lower()
    if not twitch_login:
        return await interaction.response.send_message("‚ö†Ô∏è Donne ton pseudo Twitch : /linktwitch <pseudo>", ephemeral=True)

    now = datetime.utcnow()
    try:
        liens.update_one(
            {"_id": twitch_login},
            {"$set": {
                "_id": twitch_login,
                "discord_id": str(interaction.user.id),
                "updated_at": now
            }, "$setOnInsert": {
                "created_at": now
            }},
            upsert=True
        )
        await interaction.response.send_message(
            f"üîó Lien enregistr√© : **{twitch_login}** ‚Üî <@{interaction.user.id}>",
            ephemeral=True
        )
    except Exception as e:
        print("linktwitch error:", e)
        await interaction.response.send_message("‚ùå Erreur lors de l'enregistrement. R√©essaie plus tard.", ephemeral=True)

@bot.tree.command(name="unlinktwitch", description="D√©lier ton compte Twitch")
async def unlinktwitch(interaction: discord.Interaction):
    try:
        res = liens.delete_one({"discord_id": str(interaction.user.id)})
        if res.deleted_count:
            await interaction.response.send_message("üóùÔ∏è Lien supprim√©.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ÑπÔ∏è Aucun lien trouv√©.", ephemeral=True)
    except Exception as e:
        print("unlinktwitch error:", e)
        await interaction.response.send_message("‚ùå Erreur. R√©essaie plus tard.", ephemeral=True)

# ======================
#   HTTP API (lookup Twitch -> Discord ID)
# ======================
LOOKUP_TOKEN = os.getenv("LOOKUP_TOKEN", "").strip()

async def handle_lookup(request):
    # Auth simple par header
    token = request.headers.get("X-Auth-Token")
    if not LOOKUP_TOKEN or token != LOOKUP_TOKEN:
        return web.json_response({"error": "unauthorized"}, status=401)

    twitch = (request.query.get("twitch") or "").strip().lower()
    if not twitch:
        return web.json_response({"error": "missing twitch"}, status=400)

    doc = liens.find_one({"_id": twitch})
    if not doc:
        return web.json_response({"found": False, "twitch_login": twitch})

    return web.json_response({"found": True, "twitch_login": twitch, "discord_id": doc.get("discord_id")})

async def start_api():
    try:
        app = web.Application()
        app.router.add_get("/map/lookup", handle_lookup)
        runner = web.AppRunner(app)
        await runner.setup()
        port = int(os.getenv("PORT", "3000"))
        site = web.TCPSite(runner, "0.0.0.0", port)
        await site.start()
        print(f"üîó API Lookup d√©marr√©e sur :{port} (/map/lookup)")
    except Exception as e:
        print("‚ùå HTTP API error:", e)

# ======================
#   EVENTS
# ======================
from discord import app_commands

# ... (tes definitions / imports / commandes @bot.tree.command ci-dessus)

@bot.event
async def on_ready():
    print(f"‚úÖ Oracle connect√© en tant que {bot.user} | Filtre GUILD_ID = {GUILD_ID or 'aucun'}")

    # 1) DEBUG : lister les commandes enregistr√©es dans le tree
    cmds = bot.tree.get_commands()
    print(f"üß≠ {len(cmds)} commandes app pr√©sentes dans le tree: {[c.name for c in cmds]}")

    # 2) SYNC cibl√©e par guilde(s) pour apparition instantan√©e
    try:
        if GUILD_ID:
            guild_obj = discord.Object(id=GUILD_ID)
            # (optionnel) si tu avais d√©j√† des globales, tu peux les copier dans la guilde
            # bot.tree.copy_global_to_guild(guild=guild_obj)
            synced = await bot.tree.sync(guild=guild_obj)
            print(f"üü¢ Slash sync GUILD {GUILD_ID} ‚Üí {len(synced)} cmds")
        else:
            synced = await bot.tree.sync()  # global (plus lent √† appara√Ætre)
            print(f"üü¢ Slash sync GLOBAL ‚Üí {len(synced)} cmds")
    except Exception as e:
        print("‚ö†Ô∏è Slash sync error:", e)

    # 3) D√©marre l‚ÄôAPI lookup si besoin
    try:
        bot.loop.create_task(start_api())
    except Exception as e:
        print("‚ö†Ô∏è start_api error:", e)

    # 4) Tes t√¢ches existantes
    cleanup_roles.start()


@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    # Filtre de guilde si d√©fini
    if GUILD_ID and payload.guild_id != GUILD_ID:
        return
    # ignore le bot lui-m√™me
    if payload.user_id == bot.user.id:
        return

    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    member = guild.get_member(payload.user_id)
    if not member or member.bot:
        return

    emoji = str(payload.emoji)
    channel = bot.get_channel(payload.channel_id)
    message_id = payload.message_id

    # Debug
    print(f"üì© R√©action: {emoji} | msg={message_id} | user={member.display_name}")

    # Identifier la divinit√© par le message
    deity_name, deity = find_deity_by_message(message_id)
    if not deity:
        # Pas un message d'autel
        return

    # Document utilisateur
    user_id = str(member.id)
    user = utilisateurs.find_one({"_id": user_id})
    if not user:
        utilisateurs.insert_one({
            "_id": user_id,
            "pseudo": member.name,
            "lumes": 0,
            "derniere_benediction": "",
            "roles_temporaires": {},   # { role_name: iso_timestamp }
            "offrandes": {},           # { "Orrak": "YYYY-MM-DD", ... }
            "dernier_autel": ""        # nom de la divinit√© de la derni√®re b√©n√©diction
        })
        user = utilisateurs.find_one({"_id": user_id}) or {}

    today = today_str()

    # ----- PRI√àRE (b√©n√©diction: 1/jour global) -----
    if emoji == deity["priere_emoji"]:
        last_bless = user.get("derniere_benediction", "")
        if last_bless == today:
            # d√©j√† b√©ni¬∑e aujourd'hui ‚Üí MP avec r√¥le + autel
            roles_temp = user.get("roles_temporaires", {}) or {}
            role_name = next(iter(roles_temp.keys()), None)  # ex: "B√©ni¬∑e par la Terre"
            autel_precis = user.get("dernier_autel") or deity_name

            if role_name:
                msg = f"‚ú® Tu as d√©j√† re√ßu une b√©n√©diction aujourd‚Äôhui : **{role_name}**."
            else:
                msg = f"‚ú® Tu as d√©j√† re√ßu une b√©n√©diction aujourd‚Äôhui (Autel de {autel_precis})."

            try:
                await member.send(msg)
            except Forbidden:
                await send_temp(channel, msg, 10)
            return

        role_name = deity["role"]
        role = discord.utils.get(guild.roles, name=role_name)
        if role is None:
            try:
                role = await guild.create_role(name=role_name, reason="Oracle: b√©n√©diction")
            except Forbidden:
                print(f"‚ùå Impossible de cr√©er le r√¥le {role_name} (permissions).")
                return

        try:
            await member.add_roles(role, reason="Oracle: b√©n√©diction du jour")
        except Forbidden:
            print(f"‚ùå Impossible d'ajouter le r√¥le {role_name} √† {member.display_name}.")
            return

        utilisateurs.update_one(
            {"_id": user_id},
            {"$set": {
                "derniere_benediction": today,
                f"roles_temporaires.{role_name}": datetime.utcnow().isoformat(),
                "pseudo": member.name,
                "dernier_autel": deity_name  # <-- on enregistre le nom de l'autel
            }},
            upsert=True
        )
        await send_temp(channel, f"‚ú® {member.mention} re√ßoit la b√©n√©diction **{role_name}** (Autel de {deity_name}).", 30)
        return

    # ----- OFFRANDE (Lumes: 1/jour par divinit√©) -----
    if emoji in deity["offrandes"]:
        last_offrande = (user.get("offrandes") or {}).get(deity_name, "")
        if last_offrande == today:
            await send_temp(channel, f"‚ö†Ô∏è {member.mention}, tu as d√©j√† fait une offrande √† **{deity_name}** aujourd‚Äôhui.", 10)
            return

        utilisateurs.update_one(
            {"_id": user_id},
            {"$set": {
                f"offrandes.{deity_name}": today,
                "pseudo": member.name
            }, "$inc": {
                "lumes": LUMES_PAR_OFFRANDE
            }},
            upsert=True
        )
        await send_temp(
            channel,
            f"üè± Offrande accept√©e par **{deity_name}**. "
            f"{member.mention} gagne **+{LUMES_PAR_OFFRANDE} Lumes**.",
            30
        )
        return

    # Sinon: emoji non g√©r√© pour cet autel ‚Üí on ignore
    print(f"‚ÑπÔ∏è Emoji {emoji} ignor√© pour l'autel {deity_name}.")

# ======================
#   T√ÇCHE: nettoyage r√¥les (24h)
# ======================
@tasks.loop(hours=1)
async def cleanup_roles():
    try:
        now = datetime.utcnow()
        for guild in bot.guilds:
            for member in guild.members:
                if member.bot:
                    continue
                user_id = str(member.id)
                user = utilisateurs.find_one({"_id": user_id}) or {}
                roles_temp = user.get("roles_temporaires", {}) or {}
                to_unset = []

                for role_name, iso_ts in roles_temp.items():
                    try:
                        assigned = datetime.fromisoformat(iso_ts)
                    except Exception:
                        to_unset.append(role_name)
                        continue
                    if now - assigned >= timedelta(hours=DUREE_BENEDICTION_H):
                        role = discord.utils.get(guild.roles, name=role_name)
                        if role and role in member.roles:
                            try:
                                await member.remove_roles(role, reason="Oracle: b√©n√©diction expir√©e")
                            except Forbidden:
                                pass
                        to_unset.append(role_name)

                if to_unset:
                    utilisateurs.update_one(
                        {"_id": user_id},
                        {"$unset": {f"roles_temporaires.{r}": "" for r in to_unset}}
                    )
    except Exception as e:
        print("‚ö†Ô∏è cleanup_roles error:", e)

# ======================
#   COMMANDE B√âN√âDICTION
# ======================
@bot.command(name="benediction")
async def benediction(ctx: commands.Context):
    user_id = str(ctx.author.id)
    user = utilisateurs.find_one({"_id": user_id}) or {}
    today = today_str()

    if user.get("derniere_benediction") == today:
        roles_temp = user.get("roles_temporaires", {}) or {}
        role_name = next(iter(roles_temp.keys()), "B√©n√©diction active")
        autel_precis = user.get("dernier_autel", None)
        if autel_precis and role_name != "B√©n√©diction active":
            await ctx.send(f"‚ú® {ctx.author.mention}, ta b√©n√©diction du jour est **{role_name}** (Autel de {autel_precis}).")
        else:
            await ctx.send(f"‚ú® {ctx.author.mention}, ta b√©n√©diction du jour est **{role_name}**.")
    else:
        await ctx.send(f"üåô {ctx.author.mention}, tu n‚Äôas pas encore re√ßu de b√©n√©diction aujourd‚Äôhui.")

# ======================
#   START
# ======================
if __name__ == "__main__":
    bot.run(TOKEN)
