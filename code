import os
import asyncio
from datetime import datetime, timedelta
import discord
from discord.ext import commands, tasks
from discord.errors import Forbidden
from pymongo import MongoClient

# -------- CONFIG --------
TOKEN = os.getenv("DISCORD_TOKEN")
MONGO_URI = os.getenv("MONGO_URI")
GUILD_ID = int(os.getenv("GUILD_ID", "0"))

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
intents.reactions = True

bot = commands.Bot(command_prefix="!", intents=intents)

# -------- BASE DE DONN√âES --------
cluster = MongoClient(MONGO_URI)
db = cluster["lumharel"]
utilisateurs = db["utilisateurs"]

# -------- PARAM√àTRES DES AUTELS --------
PRIERES = {
    "üåø": "B√©ni¬∑e par la Terre",
    "üî•": "Marqu√©¬∑e par la Flamme",
    "üå™Ô∏è": "Guid√©¬∑e par les Vents",
    "üåë": "Voil√©¬∑e par les Ombres",
    "‚ùÑÔ∏è": "Port√©¬∑e par le Silence"
}

OFFRANDES = {
    "üåø": 5,
    "üî•": 5,
    "üå™Ô∏è": 5,
    "üåë": 5,
    "‚ùÑÔ∏è": 5
}

# -------- OUTILS --------
async def send_temp(channel, message, seconds=10):
    """Envoie un message temporaire qui s'efface apr√®s X secondes"""
    msg = await channel.send(message)
    await asyncio.sleep(seconds)
    try:
        await msg.delete()
    except:
        pass

# -------- √âV√âNEMENT : R√©action ajout√©e --------
@bot.event
async def on_raw_reaction_add(payload):
    if payload.guild_id != GUILD_ID:
        return
    if payload.user_id == bot.user.id:
        return

    guild = bot.get_guild(payload.guild_id)
    member = guild.get_member(payload.user_id)
    if not member:
        return

    emoji = str(payload.emoji)
    channel = guild.get_channel(payload.channel_id)
    message = await channel.fetch_message(payload.message_id)

    today = datetime.utcnow().strftime("%Y-%m-%d")
    user_id = str(payload.user_id)
    user_data = utilisateurs.find_one({"_id": user_id}) or {"_id": user_id}

    # -------- PRI√àRES (r√¥les temporaires) --------
    if emoji in PRIERES:
        # üîí Limite : 1 b√©n√©diction par jour
        last_bless = (user_data.get("derniere_benediction") or "")
        if last_bless == today:
            try:
                await member.send("‚ö†Ô∏è Tu as d√©j√† re√ßu une b√©n√©diction aujourd‚Äôhui. Reviens demain üåô")
            except Forbidden:
                await send_temp(channel, f"‚ö†Ô∏è {member.mention}, tu as d√©j√† re√ßu une b√©n√©diction aujourd‚Äôhui.", seconds=10)
            return

        role_name = PRIERES[emoji]
        role = discord.utils.get(guild.roles, name=role_name)
        if role is None:
            try:
                role = await guild.create_role(name=role_name, reason="Cr√©ation auto par Oracle (pri√®re)")
            except Forbidden:
                print(f"‚ùå Permission insuffisante pour cr√©er le r√¥le {role_name}")
                return

        try:
            await member.add_roles(role, reason="B√©n√©diction via pri√®re")
        except Forbidden:
            print(f"‚ùå Impossible d'ajouter le r√¥le {role_name} √† {member.display_name}")
        else:
            # Enregistre la date de b√©n√©diction
            utilisateurs.update_one(
                {"_id": user_id},
                {"$set": {
                    f"roles_temporaires.{role_name}": datetime.utcnow().isoformat(),
                    "derniere_benediction": today
                }},
                upsert=True
            )
            if channel:
                await send_temp(channel, f"‚ú® {member.mention} a re√ßu la b√©n√©diction : **{role_name}**.", seconds=30)
        return

    # -------- OFFRANDES --------
    if emoji in OFFRANDES:
        last_offrande = user_data.get("offrandes", {}).get(emoji, {}).get("date", "")
        if last_offrande == today:
            await send_temp(channel, f"‚ö†Ô∏è {member.mention}, tu as d√©j√† fait une offrande √† cet autel aujourd‚Äôhui.", seconds=10)
            return

        lumes = user_data.get("lumes", 0) + OFFRANDES[emoji]
        utilisateurs.update_one(
            {"_id": user_id},
            {"$set": {
                f"offrandes.{emoji}.date": today,
                "lumes": lumes
            }},
            upsert=True
        )
        await send_temp(channel, f"üåü {member.mention} a offert un pr√©sent et gagne **{OFFRANDES[emoji]} Lumes**. Total : {lumes} Lumes.", seconds=30)
        return

# -------- T√ÇCHE : Nettoyage des b√©n√©dictions expir√©es --------
@tasks.loop(minutes=30)
async def nettoyage_roles():
    guild = bot.get_guild(GUILD_ID)
    if not guild:
        return

    now = datetime.utcnow()
    for user_data in utilisateurs.find():
        user_id = int(user_data["_id"])
        member = guild.get_member(user_id)
        if not member:
            continue

        roles_temp = user_data.get("roles_temporaires", {})
        for role_name, timestamp in list(roles_temp.items()):
            try:
                role = discord.utils.get(guild.roles, name=role_name)
                if not role:
                    continue

                dt = datetime.fromisoformat(timestamp)
                if now - dt > timedelta(hours=24):
                    await member.remove_roles(role, reason="Fin de b√©n√©diction (24h)")
                    utilisateurs.update_one(
                        {"_id": str(user_id)},
                        {"$unset": {f"roles_temporaires.{role_name}": ""}}
                    )
            except Exception as e:
                print(f"Erreur nettoyage r√¥le {role_name} pour {member.display_name} : {e}")

# -------- EVENTS --------
@bot.event
async def on_ready():
    print(f"‚úÖ Connect√© en tant que {bot.user}")
    nettoyage_roles.start()

# -------- LANCEMENT --------
bot.run(TOKEN)
