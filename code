import os
import sys
import asyncio
from datetime import datetime, timedelta

import discord
from discord.ext import commands, tasks
from discord.errors import Forbidden
from pymongo import MongoClient

# ======================
#   ENV & INTENTS
# ======================
TOKEN = os.getenv("DISCORD_TOKEN")
MONGO_URI = os.getenv("MONGO_URI")
GUILD_ID_STR = os.getenv("GUILD_ID", "").strip()
GUILD_ID = int(GUILD_ID_STR) if GUILD_ID_STR.isdigit() else 0  # 0 = pas de filtre

if not TOKEN:
    print("‚ùå DISCORD_TOKEN manquant en variable d'environnement.")
    sys.exit(1)
if not MONGO_URI:
    print("‚ùå MONGO_URI manquant en variable d'environnement.")
    sys.exit(1)

intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.reactions = True
intents.message_content = True
intents.messages = True

bot = commands.Bot(command_prefix="!", intents=intents)

# ======================
#   MONGO
# ======================
try:
    mongo = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
    mongo.admin.command("ping")
    print("üü¢ MongoDB OK")
except Exception as e:
    print("üî¥ MongoDB KO:", e)
    sys.exit(1)

db = mongo.lumharel_bot
utilisateurs = db.utilisateurs

# ======================
#   PARAM√àTRES AUTELS
# ======================
# D√©finir 1 message Discord par divinit√© (m√™me message pour pri√®res & offrandes)
DEITES = {
    "Orrak": {
        "message_id": 1353249202523865153,
        "priere_emoji": "üåø",
        "role": "B√©ni¬∑e par la Terre",
        "offrandes": ["üçÉ", "üå∞", "üçÑ", "üçÇ"],
    },
    "Vaek": {
        "message_id": 1353255384948801637,
        "priere_emoji": "üî•",
        "role": "Marqu√©¬∑e par la Flamme",
        "offrandes": ["üß®", "üî®", "üîß", "üß±"],
    },
    "Nhyara": {
        "message_id": 1353255533544734751,
        "priere_emoji": "üå™Ô∏è",
        "role": "Guid√©¬∑e par les Vents",
        "offrandes": ["üí®", "üéê", "üå¨Ô∏è", "üí´"],
    },
    "Zeroth": {
        "message_id": 1353255680462819450,
        "priere_emoji": "üåë",
        "role": "Voil√©¬∑e par les Ombres",
        "offrandes": ["‚ö∞Ô∏è", "üï∏Ô∏è", "üñ§", "üóùÔ∏è"],
    },
    "A√´ldis": {
        "message_id": 1353257057679052910,
        "priere_emoji": "‚ùÑÔ∏è",
        "role": "Port√©¬∑e par le Silence",
        "offrandes": ["‚òÉÔ∏è", "üßä", "üåô", "‚òÅÔ∏è"],
    },
}

LUMES_PAR_OFFRANDE = 5
DUREE_BENEDICTION_H = 24  # pour le nettoyage du r√¥le, c√¥t√© base

# ======================
#   HELPERS
# ======================
def today_str() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d")

async def send_temp(channel: discord.abc.Messageable | None, content: str, seconds: int = 10):
    if not channel:
        return
    try:
        m = await channel.send(content)
        await asyncio.sleep(seconds)
        try:
            await m.delete()
        except:
            pass
    except:
        pass

def find_deity_by_message(message_id: int):
    for name, conf in DEITES.items():
        if conf["message_id"] == message_id:
            return name, conf
    return None, None

# ======================
#   EVENTS
# ======================
@bot.event
async def on_ready():
    print(f"‚úÖ Oracle connect√© en tant que {bot.user} | Filtre GUILD_ID = {GUILD_ID or 'aucun'}")
    cleanup_roles.start()

@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    # Filtre de guilde si d√©fini
    if GUILD_ID and payload.guild_id != GUILD_ID:
        return
    # ignore le bot lui-m√™me
    if payload.user_id == bot.user.id:
        return

    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    member = guild.get_member(payload.user_id)
    if not member or member.bot:
        return

    emoji = str(payload.emoji)
    channel = bot.get_channel(payload.channel_id)
    message_id = payload.message_id

    # Debug
    print(f"üì© R√©action: {emoji} | msg={message_id} | user={member.display_name}")

    # Identifier la divinit√© par le message
    deity_name, deity = find_deity_by_message(message_id)
    if not deity:
        # Pas un message d'autel
        return

    # Document utilisateur
    user_id = str(member.id)
    user = utilisateurs.find_one({"_id": user_id})
    if not user:
        utilisateurs.insert_one({
            "_id": user_id,
            "pseudo": member.name,
            "lumes": 0,
            "derniere_benediction": "",
            "roles_temporaires": {},   # { role_name: iso_timestamp }
            "offrandes": {}           # { "Orrak": "YYYY-MM-DD", ... }
        })
        user = utilisateurs.find_one({"_id": user_id}) or {}

    today = today_str()

    # ----- PRI√àRE (b√©n√©diction: 1/jour global) -----
    if emoji == deity["priere_emoji"]:
        last_bless = user.get("derniere_benediction", "")
        if last_bless == today:
            # d√©j√† b√©ni¬∑e aujourd'hui
            try:
                await member.send("‚ö†Ô∏è Tu as d√©j√† re√ßu une b√©n√©diction aujourd‚Äôhui. Reviens demain üåô")
            except Forbidden:
                await send_temp(channel, f"‚ö†Ô∏è {member.mention}, tu as d√©j√† re√ßu une b√©n√©diction aujourd‚Äôhui.", 10)
            return

        role_name = deity["role"]
        role = discord.utils.get(guild.roles, name=role_name)
        if role is None:
            try:
                role = await guild.create_role(name=role_name, reason="Oracle: b√©n√©diction")
            except Forbidden:
                print(f"‚ùå Impossible de cr√©er le r√¥le {role_name} (permissions).")
                return

        try:
            await member.add_roles(role, reason="Oracle: b√©n√©diction du jour")
        except Forbidden:
            print(f"‚ùå Impossible d'ajouter le r√¥le {role_name} √† {member.display_name}.")
            return

        utilisateurs.update_one(
            {"_id": user_id},
            {"$set": {
                "derniere_benediction": today,
                f"roles_temporaires.{role_name}": datetime.utcnow().isoformat(),
                "pseudo": member.name
            }},
            upsert=True
        )
        await send_temp(channel, f"‚ú® {member.mention} re√ßoit la b√©n√©diction **{role_name}**.", 30)
        return

    # ----- OFFRANDE (Lumes: 1/jour par divinit√©) -----
    if emoji in deity["offrandes"]:
        last_offrande = (user.get("offrandes") or {}).get(deity_name, "")
        if last_offrande == today:
            await send_temp(channel, f"‚ö†Ô∏è {member.mention}, tu as d√©j√† fait une offrande √† **{deity_name}** aujourd‚Äôhui.", 10)
            return

        utilisateurs.update_one(
            {"_id": user_id},
            {"$set": {
                f"offrandes.{deity_name}": today,
                "pseudo": member.name
            }, "$inc": {
                "lumes": LUMES_PAR_OFFRANDE
            }},
            upsert=True
        )
        await send_temp(
            channel,
            f"üè± Offrande accept√©e par **{deity_name}**. "
            f"{member.mention} gagne **+{LUMES_PAR_OFFRANDE} Lumes**.",
            30
        )
        return

    # Sinon: emoji non g√©r√© pour cet autel ‚Üí on ignore
    print(f"‚ÑπÔ∏è Emoji {emoji} ignor√© pour l'autel {deity_name}.")

# ======================
#   T√ÇCHE: nettoyage r√¥les (24h)
# ======================
@tasks.loop(hours=1)
async def cleanup_roles():
    try:
        now = datetime.utcnow()
        for guild in bot.guilds:
            for member in guild.members:
                if member.bot:
                    continue
                user_id = str(member.id)
                user = utilisateurs.find_one({"_id": user_id}) or {}
                roles_temp = user.get("roles_temporaires", {}) or {}
                to_unset = []

                for role_name, iso_ts in roles_temp.items():
                    try:
                        assigned = datetime.fromisoformat(iso_ts)
                    except Exception:
                        to_unset.append(role_name)
                        continue
                    if now - assigned >= timedelta(hours=DUREE_BENEDICTION_H):
                        role = discord.utils.get(guild.roles, name=role_name)
                        if role and role in member.roles:
                            try:
                                await member.remove_roles(role, reason="Oracle: b√©n√©diction expir√©e")
                            except Forbidden:
                                pass
                        to_unset.append(role_name)

                if to_unset:
                    utilisateurs.update_one(
                        {"_id": user_id},
                        {"$unset": {f"roles_temporaires.{r}": "" for r in to_unset}}
                    )
    except Exception as e:
        print("‚ö†Ô∏è cleanup_roles error:", e)

# ======================
#   COMMANDES
# ======================
@bot.command(name="oracle_lumes")
async def oracle_lumes(ctx: commands.Context):
    user_id = str(ctx.author.id)
    user = utilisateurs.find_one({"_id": user_id}) or {}
    lumes = user.get("lumes", 0)
    await ctx.send(f"üí∞ {ctx.author.mention}, tu poss√®des **{lumes} Lumes**.")

@bot.command(name="benediction")
async def benediction(ctx: commands.Context):
    user_id = str(ctx.author.id)
    user = utilisateurs.find_one({"_id": user_id}) or {}
    today = today_str()
    if user.get("derniere_benediction") == today:
        # essaie d‚Äôinf√©rer le r√¥le courant √† partir des r√¥les_temporaires
        roles_temp = user.get("roles_temporaires", {}) or {}
        role_name = next(iter(roles_temp.keys()), "B√©n√©diction active")
        await ctx.send(f"‚ú® {ctx.author.mention}, ta b√©n√©diction du jour est **{role_name}**.")
    else:
        await ctx.send(f"üåô {ctx.author.mention}, tu n‚Äôas pas encore re√ßu de b√©n√©diction aujourd‚Äôhui.")

# ======================
#   START
# ======================
if __name__ == "__main__":
    bot.run(TOKEN)
