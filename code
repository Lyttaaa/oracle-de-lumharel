import os
import asyncio
from datetime import datetime, timedelta

import discord
from discord.ext import commands
from discord.errors import Forbidden
from pymongo import MongoClient

# ======================
#   CONFIG BOT & DB
# ======================
intents = discord.Intents.default()
intents.members = True
intents.guilds = True
intents.reactions = True
intents.message_content = True

bot = commands.Bot(command_prefix="!", intents=intents)

# Variables d'environnement attendues:
# - DISCORD_TOKEN
# - MONGO_URI
TOKEN = os.getenv("DISCORD_TOKEN")
MONGO_URI = os.getenv("MONGO_URI")

mongo_client = MongoClient(MONGO_URI)
db = mongo_client.lumharel_bot
utilisateurs = db.utilisateurs  # m√™me collection que tes autres bots pour partager les Lumes

# ======================
#   AUTELS & CONFIG
# ======================

# Associer chaque message d'autel √† sa divinit√© (IDs des messages d'autels d√©j√† post√©s sur ton serveur)
AUTELS = {
    1353249202523865153: "Orrak",
    1353255384948801637: "Vaek",
    1353255533544734751: "Nhyara",
    1353255680462819450: "Zeroth",
    1353257057679052910: "A√´ldis",
}

# Emojis d'offrande accept√©s par divinit√©
OFFRANDES = {
    "Orrak": ["üçÉ", "üå∞", "üçÑ", "üçÇ"],
    "Vaek": ["üß®", "üî®", "üîß", "üß±"],
    "Nhyara": ["üí®", "üéê", "üå¨Ô∏è", "üí´"],
    "Zeroth": ["‚ö∞Ô∏è", "üï∏Ô∏è", "üñ§", "üóùÔ∏è"],
    "A√´ldis": ["‚òÉÔ∏è", "üßä", "üåô", "‚òÅÔ∏è"],
}

# Emojis de pri√®re ‚Üí nom de r√¥le attribu√© 24h
PRIERES = {
    "üåø": "B√©ni¬∑e par la Terre",
    "üî•": "Marqu√©¬∑e par la Flamme",
    "üå™Ô∏è": "Guid√©¬∑e par les Vents",
    "üåë": "Voil√©¬∑e par les Ombres",
    "‚ùÑÔ∏è": "Port√©¬∑e par le Silence",
}

# R√©compense d'une offrande (Lumes) et dur√©e des b√©n√©dictions
LUMES_PAR_OFFRANDE = 3
DUREE_BENEDICTION_H = 24


# ======================
#   HELPERS
# ======================
def today_utc_str() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d")


async def send_temp(channel: discord.abc.Messageable, content: str, seconds: int = 10):
    """Envoie un message temporaire (supprim√© apr√®s n secondes)."""
    try:
        msg = await channel.send(content)
        await asyncio.sleep(seconds)
        try:
            await msg.delete()
        except:
            pass
    except:
        pass


# ======================
#   EVENTS
# ======================
@bot.event
async def on_ready():
    print(f"‚úÖ Oracle connect√© : {bot.user}")
    # Lance la t√¢che de nettoyage des r√¥les temporaires
    asyncio.create_task(cleanup_roles_task())
    print("‚è∞ T√¢che de nettoyage des r√¥les d√©marr√©e (toutes les heures).")


@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    # On ne traite que les r√©actions sur les messages d'autels
    if payload.message_id not in AUTELS:
        return

    guild = bot.get_guild(payload.guild_id)
    if guild is None:
        return

    member = guild.get_member(payload.user_id)
    if member is None or member.bot:
        return

    channel = bot.get_channel(payload.channel_id)
    emoji = str(payload.emoji)
    divinite = AUTELS[payload.message_id]
    today = today_utc_str()
    user_id = str(member.id)

    # Assure l'existence du document utilisateur
    user_data = utilisateurs.find_one({"_id": user_id})
    if not user_data:
        utilisateurs.insert_one({
            "_id": user_id,
            "pseudo": member.name,
            "lumes": 0,
            "derniere_offrande": {},    # { "Orrak": "YYYY-MM-DD", ... }
            "roles_temporaires": {}     # { "NomRole": "ISO_TIMESTAMP" }
        })
        user_data = utilisateurs.find_one({"_id": user_id})

    # -------- PRI√àRES (r√¥les temporaires) --------
    if emoji in PRIERES:
        role_name = PRIERES[emoji]
        role = discord.utils.get(guild.roles, name=role_name)
        if role is None:
            try:
                role = await guild.create_role(name=role_name, reason="Cr√©ation auto par Oracle (pri√®re)")
            except Forbidden:
                print(f"‚ùå Permission insuffisante pour cr√©er le r√¥le {role_name}")
                return

        try:
            await member.add_roles(role, reason="B√©n√©diction via pri√®re")
        except Forbidden:
            print(f"‚ùå Impossible d'ajouter le r√¥le {role_name} √† {member.display_name}")
        else:
            # Enregistre l'heure d'attribution
            utilisateurs.update_one(
                {"_id": user_id},
                {"$set": {f"roles_temporaires.{role_name}": datetime.utcnow().isoformat()}}
            )
            # Message de confirmation
            if channel:
                await send_temp(channel, f"‚ú® {member.mention} a re√ßu la b√©n√©diction : **{role_name}**.", seconds=30)

    # -------- OFFRANDES (Lumes) --------
    # Une offrande est valide seulement si l'emoji appartient √† la liste de la divinit√© de l'autel.
    if emoji in OFFRANDES.get(divinite, []):
        derniere = (user_data.get("derniere_offrande") or {}).get(divinite, "")

        # D√©j√† offert aujourd'hui ‚Üí message discret
        if derniere == today:
            # Essaye MP, sinon message temporaire dans le salon
            try:
                await member.send(f"‚ö†Ô∏è Tu as d√©j√† fait ton offrande √† **{divinite}** aujourd‚Äôhui. Reviens demain üåô")
            except Forbidden:
                if channel:
                    await send_temp(channel, f"‚ö†Ô∏è {member.mention}, tu as d√©j√† fait ton offrande √† **{divinite}** aujourd‚Äôhui.", seconds=10)
            return

        # Enregistre l'offrande + Lumes
        utilisateurs.update_one(
            {"_id": user_id},
            {
                "$set": {f"derniere_offrande.{divinite}": today, "pseudo": member.name},
                "$inc": {"lumes": LUMES_PAR_OFFRANDE}
            },
            upsert=True
        )

        if channel:
            await send_temp(
                channel,
                f"üè± Une offrande a √©t√© faite √† **{divinite}**. "
                f"Les esprits murmurent leur gratitude √† {member.mention}. "
                f"(+{LUMES_PAR_OFFRANDE} Lumes)",
                seconds=30
            )


# ======================
#   T√ÇCHE DE NETTOYAGE
# ======================
async def cleanup_roles_task():
    """Retire les r√¥les de b√©n√©diction apr√®s 24h."""
    while True:
        try:
            now = datetime.utcnow()
            for guild in bot.guilds:
                for member in guild.members:
                    if member.bot:
                        continue
                    user_id = str(member.id)
                    user_data = utilisateurs.find_one({"_id": user_id})
                    if not user_data:
                        continue

                    roles_temp = user_data.get("roles_temporaires", {}) or {}
                    to_remove = []
                    for role_name, iso_ts in roles_temp.items():
                        try:
                            assigned_time = datetime.fromisoformat(iso_ts)
                        except Exception:
                            # Timestamp corrompu ‚Üí on retire le suivi
                            to_remove.append(role_name)
                            continue

                        if now - assigned_time >= timedelta(hours=DUREE_BENEDICTION_H):
                            role = discord.utils.get(guild.roles, name=role_name)
                            if role and role in member.roles:
                                try:
                                    await member.remove_roles(role, reason="B√©n√©diction expir√©e")
                                except Forbidden:
                                    pass
                            to_remove.append(role_name)

                    # Nettoyage en base
                    if to_remove:
                        unset_fields = {f"roles_temporaires.{r}": "" for r in to_remove}
                        utilisateurs.update_one({"_id": user_id}, {"$unset": unset_fields})
        except Exception as e:
            print("‚ö†Ô∏è Erreur cleanup_roles_task:", e)

        # V√©rifie toutes les heures
        await asyncio.sleep(3600)


# ======================
#   COMMANDES UTILES
# ======================
@bot.command(name="bourse")
async def bourse(ctx: commands.Context):
    """Affiche les Lumes du joueur."""
    user_id = str(ctx.author.id)
    user_data = utilisateurs.find_one({"_id": user_id}) or {}
    lumes = user_data.get("lumes", 0)
    await ctx.send(f"üí∞ {ctx.author.mention}, tu poss√®des actuellement **{lumes} Lumes**.")

@bot.command(name="oracle_debug")
@commands.has_permissions(administrator=True)
async def oracle_debug(ctx: commands.Context):
    """Diagnostic rapide Oracle (admin)."""
    await ctx.send(
        "üß™ **Oracle Debug**\n"
        f"- Autels connus : {', '.join([f'{k}:{v}' for k,v in AUTELS.items()])}\n"
        f"- Emojis pri√®res : {', '.join(PRIERES.keys())}\n"
        f"- Lumes/offrande : {LUMES_PAR_OFFRANDE}\n"
        f"- Dur√©e b√©n√©diction : {DUREE_BENEDICTION_H}h"
    )


# ======================
#   D√âMARRAGE
# ======================
if __name__ == "
